https://zhuanlan.zhihu.com/p/479141377

二分查找：
如果一个序列具有单调性，那么一定可以对其进行二分查找；
但使用二分查找的场景下，不一定都是单调的序列。

二分的本质其实不是单调性，是寻找【某个性质下】区间的边界：
区间上定义了某种性质，区间左半边的元素不满足该性质，区间右半边的元素满足该性质，
二分寻找的就是左半边或右半边的边界点（在整数二分情况下它们不共享边界）


二分查找有两种类型：
整数的二分、浮点数的二分。

一、整数二分
大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。
要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。
写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。
第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right]
因为定义target在[left, right]区间，所以有如下两点：
（1）while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
（2）if (nums[middle] > target)  right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的（左区间结束下标）位置就是 middle - 1

第二种写法，定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，
那么二分法的边界处理方式与第一种则截然不同。
（1）while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的。
（2）if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，
即：下一个查询区间不会去比较nums[middle]


二、浮点数二分
对于浮点数，在进行除法时不需要向下取整，因此每次区间长度都可以严格地缩小为之前的1/2，不需要处理边界问题。

浮点数循环的中止条件：（有两种）
不断地进行二分直到区间变得很短（如果题目要求结果保留4位小数，那么r-l小于等于10的-6次方即可，如果要求保留6位小数，那么r-l小于等于10的-8次方即可，总之就是要比要求的位数多2），
或者是不以精度作为循环结束的条件，而是直接循环100次，这也是可以的（因为这相当于区间长度缩小到了原来的2^100分之一，必然也是非常小的了）


浮点数二分的初始区间设定也需要注意，
比如说想通过浮点数二分求x的平方根，那么初始区间不可以设置成[0, x]，
因为如果x是小于1的数，比如说0.01，那么x的平方根其实是0.1，根本不在[0, x]这个区间里，
所以解决这个问题时设置的初始区间可以是[0, max(1, x)]


